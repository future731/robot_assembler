#!/usr/bin/env python
# -*- coding: utf-8 -*-
import rospy
import actionlib
import math
from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectoryPoint

from gazebo_msgs.msg import LinkStates
BASE=1

rospy.init_node('send_motion')
act_client = actionlib.SimpleActionClient('/fullbody_controller/follow_joint_trajectory', FollowJointTrajectoryAction)

act_client.wait_for_server()



traj_msg = FollowJointTrajectoryGoal()
traj_msg.trajectory.header.stamp = rospy.Time.now()
cnt1 = 0.0

def callback(msg):
    global cnt1
    cnt1 += 1.0
    traj_msg.trajectory.header.stamp = rospy.Time.now() + rospy.Duration(0.2)
    traj_msg.trajectory.joint_names = ['JOINT0', 'JOINT1', 'JOINT2', 'JOINT3']

##
    print(1.0 * math.sin(cnt1 * 6.28 / 100.0))
    traj_msg.trajectory.points.append(JointTrajectoryPoint(positions=[1.0 * math.sin(cnt1 * 6.28 / 100.0), 0, 0, 0], #姿勢1
                                                           time_from_start = rospy.Duration(1.0)))

# send to robot arm
    act_client.send_goal(traj_msg)

    act_client.wait_for_result()

    rospy.loginfo("done")
    rospy.loginfo("{} {}".format(rospy.get_caller_id(), msg.pose[BASE]))


if __name__ == '__main__':
    rospy.Subscriber("/gazebo/link_states", LinkStates, callback)
    rospy.spin()
